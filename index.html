<!DOCTYPE html>
<html>
<head>
  <title>Transformirror</title>
  <link rel="icon" href="data:,">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: black;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }
    #remoteVideo, #localVideo {
      height: 100%;
      width: auto;
      max-width: 100%;
      object-fit: contain;
    }
    #streamInfo {
      display: none;
    }
    #controls {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 1000;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #videoDevices {
      margin-bottom: 20px;
      padding: 10px;
      font-size: 18px;
      background-color: #333;
      color: white;
      border: 2px solid white;
      border-radius: 5px;
    }
    #startButton {
      padding: 15px 30px;
      font-size: 24px;
      background-color: black;
      color: white;
      border: 2px solid white;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.3s ease;
      touch-action: manipulation;
    }
    #startButton:hover {
      background-color: #333;
    }
    #startButton:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    #debugInfo {
      position: fixed;
      bottom: 10px;
      left: 10px;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px;
      border-radius: 5px;
      font-family: monospace;
      font-size: 12px;
      z-index: 1000;
      display: none; /* Hide debug info by default */
    }
    #keyBindings {
      margin-top: 20px;
      color: white;
      text-align: center;
    }
    #keyBindings ul {
      list-style-type: none;
      padding: 0;
    }
    #keyBindings li {
      margin: 5px 0;
    }
    #localVideo {
      display: none;
      width: 1px;
      height: 1px;
      position: absolute;
    }
  </style>
</head>
<body>
  <div id="controls">
    <select id="videoDevices"></select>
    <button id="startButton" onclick="start()">Start</button>
    <div id="keyBindings">
      <ul>
        <li>Press 'D' to toggle debug information</li>
        <li>Press 'C' to switch between local and remote video</li>
      </ul>
    </div>
  </div>
  <video id="localVideo" autoplay muted></video>
  <canvas id="remoteVideo"></canvas>
  <div id="streamInfo"></div>
  <div id="debugInfo"></div>
  <script>
    const quality = 0.5;
    let ws;
    let localStream;
    let videoTrack;
    let canvas;
    let ctx;
    let startTime;
    let sendFrameCount = 0;
    let receiveFrameCount = 0;
    let bytesSent = 0;
    let bytesReceived = 0;
    let lastUpdateTime;
    let lastBytesSent = 0;
    let lastBytesReceived = 0;
    let videoFrameCallbackId;
    let debugInfoVisible = false;
    let showingLocalVideo = false;

    // Add these new variables
    let lastThirtySendFrames = [];
    let lastThirtyReceiveFrames = [];
    let lastThirtySendBytes = [];
    let lastThirtyReceiveBytes = [];

    async function enumerateDevices() {
      const deviceSelect = document.getElementById('videoDevices');
      const devices = await navigator.mediaDevices.enumerateDevices();
      const videoDevices = devices.filter(device => device.kind === 'videoinput');
      
      videoDevices.forEach(device => {
        const option = document.createElement('option');
        option.value = device.deviceId;
        option.text = device.label || `Camera ${deviceSelect.length + 1}`;
        deviceSelect.appendChild(option);
      });
    }

    async function start() {
      const startButton = document.getElementById('startButton');
      const deviceSelect = document.getElementById('videoDevices');
      
      startButton.textContent = 'Connecting...';
      startButton.disabled = true;
      
      const selectedDeviceId = deviceSelect.value;

      localStream = await navigator.mediaDevices.getUserMedia({
        video: { 
          deviceId: selectedDeviceId ? { exact: selectedDeviceId } : undefined,
          width: 1080, 
          height: 1080, 
          frameRate: 30
        },
        audio: false
      });

      const localVideo = document.getElementById('localVideo');
      localVideo.srcObject = localStream;
      // Remove this line as we're handling display in CSS
      // localVideo.style.display = 'none';

      // Wait for the video to be ready
      await new Promise((resolve) => {
        localVideo.onloadedmetadata = () => {
          localVideo.play();
          resolve();
        };
      });

      // Check if we're getting video data
      const track = localStream.getVideoTracks()[0];
      const settings = track.getSettings();

      document.getElementById('streamInfo').innerHTML = `
        Actual stream properties:
        Width: ${settings.width}px,
        Height: ${settings.height}px,
        Frame Rate: ${settings.frameRate}fps
      `;

      canvas = document.createElement('canvas');
      canvas.width = settings.width;
      canvas.height = settings.height;
      ctx = canvas.getContext('2d', { willReadFrequently: true });

      const remoteCanvas = document.getElementById('remoteVideo');
      remoteCanvas.width = settings.width;
      remoteCanvas.height = settings.height;
      const remoteCtx = remoteCanvas.getContext('2d');

      ws = new WebSocket(`wss://${window.location.host}/ws`);

      ws.onopen = () => {
        document.getElementById('controls').style.display = 'none';
        startTime = Date.now();
        requestVideoFrame();
      };

      ws.onmessage = (event) => {
        const img = new Image();
        img.onload = () => {
          remoteCtx.drawImage(img, 0, 0);
          bytesReceived += event.data.size;
          lastBytesReceived = event.data.size;
          receiveFrameCount++;

          // Add frame info to the arrays
          const frameInfo = { timestamp: Date.now(), bytes: event.data.size };
          lastThirtyReceiveFrames.push(frameInfo);
          lastThirtyReceiveBytes.push(event.data.size);

          // Keep only the last 30 frames
          if (lastThirtyReceiveFrames.length > 30) {
            lastThirtyReceiveFrames.shift();
            lastThirtyReceiveBytes.shift();
          }

          URL.revokeObjectURL(img.src);
        };
        img.src = URL.createObjectURL(new Blob([event.data], { type: 'image/jpeg' }));
      };
    }

    function requestVideoFrame() {
      videoFrameCallbackId = localVideo.requestVideoFrameCallback(processVideoFrame);
    }

    function processVideoFrame(now, metadata) {
      ctx.drawImage(localVideo, 0, 0, canvas.width, canvas.height);
      
      // Add debugging to check if the canvas contains non-black pixels
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      let isAllBlack = true;
      for (let i = 0; i < data.length; i += 4) {
        if (data[i] !== 0 || data[i+1] !== 0 || data[i+2] !== 0) {
          isAllBlack = false;
          break;
        }
      }
      canvas.toBlob((blob) => {
        ws.send(blob);
        bytesSent += blob.size;
        lastBytesSent = blob.size;
        sendFrameCount++;

        // Add frame info to the arrays
        const frameInfo = { timestamp: Date.now(), bytes: blob.size };
        lastThirtySendFrames.push(frameInfo);
        lastThirtySendBytes.push(blob.size);

        // Keep only the last 30 frames
        if (lastThirtySendFrames.length > 30) {
          lastThirtySendFrames.shift();
          lastThirtySendBytes.shift();
        }

        updateDebugInfo();

        requestVideoFrame(); // Request the next frame
      }, 'image/jpeg', quality);
    }

    function updateDebugInfo() {
      if (!debugInfoVisible) return;

      const now = Date.now();
      if (now - lastUpdateTime < 1000) return;

      // Calculate send FPS and bandwidth based on the last 30 frames
      const sendTimeRange = lastThirtySendFrames.length > 1 ? 
        lastThirtySendFrames[lastThirtySendFrames.length - 1].timestamp - lastThirtySendFrames[0].timestamp : 1000;
      const sendFps = (lastThirtySendFrames.length / (sendTimeRange / 1000)).toFixed(2);
      const sendBandwidthKbps = ((lastThirtySendBytes.reduce((a, b) => a + b, 0) / 1024) / (sendTimeRange / 1000)).toFixed();

      // Calculate receive FPS and bandwidth based on the last 30 frames
      const receiveTimeRange = lastThirtyReceiveFrames.length > 1 ? 
        lastThirtyReceiveFrames[lastThirtyReceiveFrames.length - 1].timestamp - lastThirtyReceiveFrames[0].timestamp : 1000;
      const receiveFps = (lastThirtyReceiveFrames.length / (receiveTimeRange / 1000)).toFixed(2);
      const receiveBandwidthKbps = ((lastThirtyReceiveBytes.reduce((a, b) => a + b, 0) / 1024) / (receiveTimeRange / 1000)).toFixed();

      const lastBytesSentKb = (lastBytesSent / 1024).toFixed();
      const lastBytesReceivedKb = (lastBytesReceived / 1024).toFixed();

      const debugInfo = `
        Send FPS: ${sendFps}
        Receive FPS: ${receiveFps}
        Send Bandwidth: ${sendBandwidthKbps} Kbps
        Receive Bandwidth: ${receiveBandwidthKbps} Kbps
        Last Sent: ${lastBytesSentKb} Kb
        Last Received: ${lastBytesReceivedKb} Kb
        Total Sent: ${(bytesSent / (1024 * 1024)).toFixed(2)} MB
        Total Received: ${(bytesReceived / (1024 * 1024)).toFixed(2)} MB
      `;

      document.getElementById('debugInfo').innerText = debugInfo;
      lastUpdateTime = now;
    }

    function toggleDebugInfo(event) {
      if (event.key === 'd' || event.key === 'D') {
        debugInfoVisible = !debugInfoVisible;
        document.getElementById('debugInfo').style.display = debugInfoVisible ? 'block' : 'none';
      }
    }

    function toggleVideoView(event) {
      if (event.key === 'c' || event.key === 'C') {
        showingLocalVideo = !showingLocalVideo;
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        
        if (showingLocalVideo) {
          localVideo.style.display = 'block';
          localVideo.style.width = '100%';
          localVideo.style.height = '100%';
          localVideo.style.position = 'fixed';
          localVideo.style.top = '0';
          localVideo.style.left = '0';
          localVideo.style.objectFit = 'contain';
          remoteVideo.style.display = 'none';
        } else {
          localVideo.style.display = 'none';
          localVideo.style.width = '1px';
          localVideo.style.height = '1px';
          localVideo.style.position = 'absolute';
          remoteVideo.style.display = 'block';
        }
      }
    }

    function cleanup() {
      if (ws) {
        ws.close();
      }
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
      }
      if (videoFrameCallbackId) {
        localVideo.cancelVideoFrameCallback(videoFrameCallbackId);
      }
    }

    window.addEventListener('beforeunload', cleanup);
    document.addEventListener('keydown', toggleDebugInfo);
    document.addEventListener('keydown', toggleVideoView);

    enumerateDevices();
  </script>
</body>
</html>
